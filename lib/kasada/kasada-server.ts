import { NextFetchEvent, NextRequest, NextResponse } from 'next/server'



export interface APIRequest {
  // valid IPv4 orIPv6 address of the original client making the request
  clientIp: string
  // always provide as many of the available header from the client request
  headers: Array<{
    key: string
    value: string
  }>
  method: 'HEAD' | 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE'
  protocol: 'HTTP' | 'HTTPS'
  // /some/path
  path: string
  // request querystring including leading '?', e.g. '?foo=bar&bar=foo'
  querystring: string
  // always provide the (redacted) body if available in the client request
  body?: string
}

export interface APIResponse {
  // unique request id as generated by the API
  requestId: string
  // unique client id; only present when a client ID is available
  clientId?: string
  // API classification
  classification: 'ALLOWED' | 'BAD-BOT' | 'GOOD-BOT' | 'HUMAN'
  // array of Set-Cookie strings, like '<cookie-name>=<cookie-value>; SameSite=None; Secure'
  responseHeadersToSet: Array<{ key: string; value: string }>
  application: {
    mode: 'MONITOR' | 'PROTECT' | 'PASS_THROUGH'
    domain: string
  }
  error: string
}

/**
 * Function that fetches the Kasada classification and metadata about the request
 * and returns either this metadata or an error if something went wrong.
 */
async function getKasadaMetadata(request: NextRequest) {
  const url = new URL(request.url)

  const headers = new Headers(request.headers)
  headers.delete('x-forwarded-host')
  headers.set('Host', process.env.KASADA_HEADER_HOST || '')

  const headersArray = [...headers.entries()].map(([key, value]) => ({
    key,
    value
  }))

  const kasadaPayload: APIRequest = {
    clientIp: String(request.headers.get('x-real-ip') || request.ip),
    headers: headersArray,
    method: request.method as APIRequest['method'],
    protocol: url.protocol.slice(0, -1).toUpperCase() as APIRequest['protocol'],
    path: url.pathname,
    querystring: url.search
  }

  // Set a maximum Kasada response time of 3 seconds
  const timeout = 10000
  const timeoutController = new AbortController()
  const timeoutId = setTimeout(() => timeoutController.abort(), timeout)

}





export async function kasadaHandler(){

}
